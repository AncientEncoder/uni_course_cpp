# Задача 4

# 1. Доработать генерацию графа

Данная, и последующие задачи выполняются поверх файлов предыдущей задачи.
В вашей папке не должны находиться файлы с решением отдельных задач.
Все изменения накладываются друг на друга.
Каждый новый ПР изменяет состояние вашего проекта (вашей папки).
У вас должна быть только одна программа с одной функцией `int main()`.

## Входные параметры

Ваша программа должна запрашивать у пользователя следующие параметры:
- `depth`: Максимальная глубина графа (`int` от 0 и до бесконечности).
- `new_vertices_num`: Количество новых генерируемых вершин из каждой вершины графа (`int` от 0 и до бесконечности).

Входные параметры нужно валидировать и, в случае ошибки, информировать об этом пользователя, после чего запрашивать данные повторно.

Так как новые вершины и грани у нас будут генерироваться с определенной вероятность, может быть ситуация, когда глубина графа будет ниже заданной пользователем.
Эта ситуация нормальная, но в данном случае нужно проинформировать пользователя о финальной, получившейся глубине графа.

## Выделить генерацию графа в отдельный класс

Так как генерация графа становится все больше и сложнее, имеет смысл отделить её в отдельную сущность:
```cpp
class GraphGenerator;
```

А так же объединить входные параметры в структуру, которая содержит в себе параметры генерации:
```cpp
struct GraphGeneration::Params;
```

Интерфейс для взаимодействия с генератором должен быть следующий:
```cpp
class GraphGenerator {
 public:
  struct Params {
    explicit Params(int depth = 0, int new_vertices_num = 0) :
      depth_(depth), new_vertices_num_(new_vertices_num) {}

    const int depth = 0;
    const int new_vertices_num = 0;
  }

  explicit GraphGenerator(const Params& params = Params()) :
    params_(params) {}

  Graph generate() const;

 private:
  const Params params_ = Params();
}
```

## Новые вершины будут генерироваться с определенной вероятностью

- Пример, если `depth = 2` и `new_vertices_num = 3`:
  - Глубина графа 0:
    - 100% каждая вершина на этой глубине сгенерирует 3 новых.
  - Глубина графа 1:
    - 50% каждая вершина на этой глубине сгенерирует 3 новых.
  - Глубина графа 2:
    - 0% каждая вершина на этой глубине сгенерирует 3 новых.

- Пример, если `depth = 4` и `new_vertices_num = 5`:
  - Глубина графа 0:
    - 100% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 1:
    - 75% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 2:
    - 50% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 3:
    - 25% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 4:
    - 0% каждая вершина на этой глубине сгенерирует 5 новых.

То есть, вероятность на 0ой глубине всегда 100%, а на последней глубине всегда 0%.
Между ними вероятность должна изменяться с равным шагом.

Говоря "вершина генерирует новую вершину", я подразумеваю, что в граф добавляется новая вершина и грань, соединяющая эти две вершины.

"... каждая вершина на этой глубине сгенерирует N новых", вы можете думать об этом как:
каждая вершина имеет N попыток сгенерировать новую вершину с такой-то вероятностью.

## После того, как вершины сгенерированы, между ними могут быть добавлены дополнительные грани

- **Зеленая**: 10% что у вершины будеть грань сама на себя.
- **Синяя**: 25% что соседние вершины, находящиеся на одной глубине, будут соединены.
- **Желтая**: Вершина будет соединена с рандомной вершиной, находящейся на 1 уровень глубже, исключая её собственных потомков.
  - Вероятность обратная к обычным (серым) граням:
    - Глубина графа 0: 0%
    - . . .
    - Глубина графа N-1: 100%
- **Красная**: 33% что вершина будет соединена с рандомной вершиной, находящейся на 2 уровня глубже.

Для упрощения, примем то, что глубина графа вычисляется только из серых граней.
Все остальные грани (зеленая, синяя, желтая и красная) никак не влияют на глубину графа.

## Визуализация примера графа

![Graph](graph.png)

Данная визуализация очень упрощена и дана только как пример. Ваш граф может, и должен отличаться от нарисованного выше.

# 2. Доработать `JSON` репрезентацию
```json
{
  "depth": 6,
  "vertices": [
    {
      "id": 0,
      "edge_ids": [0, 1, 2, 43],
      "depth": 0
    },
    "..."
  ],
  "edges": [
    {
      "id": 0,
      "vertex_ids": [0, 1],
      "color": "gray"
    },
    "..."
  ]
}
```

- Возможные цвета граней: `gray`, `green`, `blue`, `yellow`, `red`.

### Функция `main` вашей программы

```cpp
// ... some other logic ...

int main() {
  const int depth = handle_depth_input();
  const int new_vertices_num = handle_new_vertices_num_input();

  const auto params = GraphGenerationParams(depth, new_vertices_num);
  const auto generator = GraphGenerator(params);
  const auto graph = generator.generate();
  const auto graph_printer = GraphPrinter(graph);
  const auto graph_json = graph_printer.print();

  std::cout << graph_json << std::endl;
  write_to_file(graph_json, "graph.json");

  return 0;
}
```

# Содержание `Pull Request`

- `*.cpp` и/или `*.hpp` исходные файлы.
- Скомпилированный бинарник.
- `graph.json` - результат выполнения программы.

# Время Выполнения

1 Неделя

# Количество Баллов

10 Баллов

# Полезные ссылки
- [Graph Depth](https://en.wikipedia.org/wiki/Tree-depth)
