# Задача 4

# 1. Доработать генерацию графа

Данная, и последующие задачи выполняются поверх файлов предыдущей задачи.
В вашей папке не должны находиться файлы с решением отдельных задач.
Все изменения накладываются друг на друга.
Каждый новый ПР изменяет состояние вашего проекта (вашей папки).
У вас должна быть только одна программа с одной функцией `int main()`.

## Входные параметры

Ваша программа должна запрашивать у пользователя следующие параметры:
- `depth`: Максимальная глубина графа (`int` от 0 и до бесконечности).
- `new_vertices_num`: Количество новых генерируемых вершин из каждой вершины графа (`int` от 0 и до бесконечности).

Входные параметры нужно валидировать и, в случае ошибки, информировать об этом пользователя, после чего запрашивать данные повторно.

Так как новые вершины и грани у нас будут генерироваться с определенной вероятность, может быть ситуация, когда финальная глубина графа будет ниже заданной пользователем.

## Выделить генерацию графа в отдельный класс

Так как генерация графа становится все больше и сложнее, имеет смысл отделить её в отдельную сущность:
```cpp
class GraphGenerator;
```

А так же объединить входные параметры в структуру, которая содержит в себе параметры генерации:
```cpp
struct GraphGeneration::Params;
```

Интерфейс для взаимодействия с генератором должен быть следующий:
```cpp
class GraphGenerator {
 public:
  struct Params {
    explicit Params(int _depth = 0, int _new_vertices_num = 0) :
      depth(_depth), new_vertices_num(_new_vertices_num) {}

    const int depth = 0;
    const int new_vertices_num = 0;
  };

  explicit GraphGenerator(const Params& params = Params()) :
    params_(params) {}

  Graph generate() const {
    auto graph = Graph();
    graph.add_vertex();
    generate_gray_edges(graph);
    generate_green_edges(graph);
    generate_yellow_edges(graph);
    generate_red_edges(graph);
  }

 private:
  const Params params_ = Params();
};
```

## Новые вершины будут генерироваться с определенной вероятностью

- Пример, если `depth = 2` и `new_vertices_num = 3`:
  - Глубина графа 0:
    - 100% каждая вершина на этой глубине сгенерирует 3 новых.
  - Глубина графа 1:
    - 50% каждая вершина на этой глубине сгенерирует 3 новых.
  - Глубина графа 2:
    - 0% каждая вершина на этой глубине сгенерирует 3 новых.

- Пример, если `depth = 4` и `new_vertices_num = 5`:
  - Глубина графа 0:
    - 100% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 1:
    - 75% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 2:
    - 50% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 3:
    - 25% каждая вершина на этой глубине сгенерирует 5 новых.
  - Глубина графа 4:
    - 0% каждая вершина на этой глубине сгенерирует 5 новых.

То есть, вероятность на 0ой глубине всегда 100%, а на последней глубине всегда 0%.
Между ними вероятность должна изменяться с равным шагом.

Говоря "вершина генерирует новую вершину", я подразумеваю, что в граф добавляется новая вершина и грань, соединяющая эти две вершины.

"... каждая вершина на этой глубине сгенерирует N новых", вы можете думать об этом как:
каждая вершина имеет N попыток сгенерировать новую вершину с такой-то вероятностью.

## После того, как вершины сгенерированы, между ними могут быть добавлены дополнительные грани

- **Зеленая**: 10% что у вершины будеть грань сама на себя.
- **Желтая**: Вершина будет соединена с рандомной вершиной, находящейся на 1 уровень глубже, исключая её собственных потомков.
  - Вероятность обратная к обычным (серым) граням:
    - Глубина графа 0: 0%
    - . . .
    - Глубина графа N-1: 100%
- **Красная**: 33% что вершина будет соединена с рандомной вершиной, находящейся на 2 уровня глубже.

## Дополнительная информация

1) Для реализации логики разных цветов граней - существует специальный инструмент - "перечисление" (по-английски "enumeration").
Соответственно у нас есть тип данных `Color`, в котором мы перечисляем набор опций: `Gray`, `Green`, `Yellow`, `Red`.
Делается это при помощи `enum class`:

```cpp
struct Edge {
  enum class Color { Gray, Green, Yellow, Red };
}
```

Находиться ему лучше внутри `Edge`, так как это не абстрактный цвет, а объект, реализующий специфическую для `Edge` логику.
Обратите вниманием что в `C++` используется `enum color`, тогда как в `C` - просто `enum`.
`enum color` лучше, так как он позволяет избежать автоматического приведения типов, что делает код надежней и позволяет компилятору отловить ошибки на ранней стадии.

Для перевода `Edge::Color` в строку, расширьте класс `GraphPrinter`:
```cpp
class GraphPrinter {
  print_edge_color(const Edge::Color& color) const;
}
```

2) По дизайну, любая новая вершина в графе, которая не связани ни с одной другой вершиной, находится на глубине 0.
При добавлении новой грани между вершинами, соотвественно изменяется глубина.
Глубина вершины вычисляется как минимальное количество шагов от начала графа до данной вершины.
Вычислять глубину вершины - ответственность графа, она не должна перекладываться на внешнего пользователя.
То же относится и к вычислению цвета грани. Публичный интерфейс графа должен оставаться неизменным.

```cpp
Vertex& add_vertex();
Edge& add_edge(const VertexId& from_vertex_id, const VertexId& to_vertex_id);
```

Вычислять глубину вершины и цвет граней нужно динамически, внутри графа, без перекладывания этой ответственности на внешнего пользователя.

Для упрощения, примем то, что глубина графа изменяется только серыми гранями. Думайте о них, как о базовых грянях.
Все остальные грани (зеленая, желтая и красная) никак не влияют на глубину графа, и являются дополнительными гранями.

Соответственно логика должна быть следующая (псевдокод):
- Глубина:
  - ```cpp
    const auto from_vertex_depth = get_vertex_depth(from_vertex_id);
    set_vertex_depth(to_vertex_id, from_vertex_depth + 1);
    ```
- Цвет:
  - ```cpp
    const auto from_vertex_depth = get_vertex_depth(from_vertex_id);
    const auto to_vertex_depth = get_vertex_depth(to_vertex_id);
    if (from_vertex_id == to_vertex_id) {
      return Edge::Color::Green;
    }
    if (get_edges(to_vertex_id).size() == 0) {
      return Edge::Color::Gray;
    }
    if (to_vertex_depth - from_vertex_depth == 1 &&
        !is_connected(from_vertex_id, to_vertex_id)) {
      return Edge::Color::Yellow;
    }
    if (to_vertex_depth - from_vertex_depth == 2) {
      return Edge::Color::Red;
    }
    throw std::runtime_error("Failed to determine color");
    ```

3) Для определения вероятностей - почитайте про [`std::bernoulli_distribution`](https://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution).
Оно реализует именно ту логику, которая нам необходима.

## Визуализация примера графа

![Graph](graph.png)

Данная визуализация очень упрощена и дана только как пример. Ваш граф может, и должен отличаться от нарисованного выше.

# 2. Доработать `JSON` репрезентацию
```json
{
  "depth": 6,
  "vertices": [
    {
      "id": 0,
      "edge_ids": [0, 1, 2, 43],
      "depth": 0
    },
    "..."
  ],
  "edges": [
    {
      "id": 0,
      "vertex_ids": [0, 1],
      "color": "gray"
    },
    "..."
  ]
}
```

- Возможные цвета граней: `gray`, `green`, `yellow`, `red`.

## Функция `main` вашей программы

```cpp
// ... some other logic ...

int main() {
  const int depth = handle_depth_input();
  const int new_vertices_num = handle_new_vertices_num_input();

  const auto params = GraphGenerationParams(depth, new_vertices_num);
  const auto generator = GraphGenerator(params);
  const auto graph = generator.generate();
  const auto graph_printer = GraphPrinter(graph);
  const auto graph_json = graph_printer.print();

  std::cout << graph_json << std::endl;
  write_to_file(graph_json, "graph.json");

  return 0;
}
```

# Содержание `Pull Request`

- `*.cpp` и/или `*.hpp` исходные файлы.
- Скомпилированный бинарник.
- `graph.json` - результат выполнения программы.

# Время Выполнения

1 Неделя.

# Количество Баллов

10 Баллов.

# Полезные ссылки
- [Graph Depth](https://en.wikipedia.org/wiki/Tree-depth)
